---
layout: tutorial
---


Lists
-----

Lists in Nominine have element type. The element type decides what type of objects can be in the list.

Lists that can contain any type of object, has element type **any**.

Lists are mutable. Operations on lists normally return the list operated upon.
If there is a type mismatch, a none object is produced.

<hr>

Tuples
------

Tuples are identical to lists, but it is useful to differentiate between tuples and other sets when building polymorphic functions.

On the other hand it is convenient to use tuples to provide **set** parameters.

<hr>

Building lists
--------------

To build a **list**, provide an element type.

        var (: 'some-list' ( list ( number ) ) )

**some-list** is a list that can only contain objects that are of type **number**.

<hr>

Appending elements to lists
---------------------------

To append more elements to a list, simply pass objects of element type to the list.
Appending elements returns the list object.

        ( some-list 4 5 6 )

<hr>

Merging
-------

To merge a **list** with another **set**, one uses the merge method. Merge takes a list as an argument.

        ( some-list merge (: 7 8 9 ) .)

Notice the use of a **tuple**.
Since **merge** takes a **set** as a parameter it can be used to append the elements of *any* **set** into the list.

<hr>

Generators
----------

Generators are programs that produce elements.

        var (: 'some-generator' ( gen (: ( number ) [ ( 1 throw .) ( 2 throw .) ( 3 throw .) ] ) ) )

To produce a generator one uses the **gen** type as a constructor. It takes as argument the type of elements
generated by the generator and a **set** representing the code block that defines the generator program. The type is
optional and has a default value of **any**.

Notice that the above generator uses **throw** to emit elements.
**some-generator** throws the elements 1, 2 and 3.
This makes it equivalent to the list or tuple with elements 1, 2 and 3.

<hr>

Sets
----

Lists, tuples and generators share the mechanism for iteration. This means that when building e.g. a function that uses a list as
a parameter, it is often better to use the type **set** instead. That way, the function can receive both lists and generators.

        fun (: 'do-something-to-all-elements' ( set ) [ ... ] )

The **set** class is only a placeholder and does not add any functionality and cannot be instantiated.

<hr>

Generator to list
-----------------

Generators do not support **append** and **merge**, but it is possible to merge a generator into a list.

        ( some-list merge ( some-generator ) .)

This will append all elements generated by some-generator into some-list. The generator needs to terminate for this to work.
This effectively converts a generator to a static list.

The **merge** method of lists takes a **set** as its parameter.

<hr>

Iterating
---------

To iterate over a set, list or generator, one must create an iterator object using the word **each**.

        var (: 'elements' ( some-set each ) )

Then one can use the word **next** to get the next element in the list.

        ( elements next )

The type of an iterator is **iterator**.

The following code iterates over all elements of **some-set** and outputs them using **delog**.

        const (: 'elements' ( some-set each ) )
        loop [
          console write ( elements next else [ stop ] )
        ]

**some-set** can be either a list or a generator, or an other type of set.
Notice that the outputting all elements in a set is best done by relying on **to-string** and optionally **join**.

<hr>

Quoted expressions
------------------

Quoted expressions are also sets.
They are lists with element type **any**.

However `[ 1 2 3 ]` does not give a set of numbers but a set of literals.
When using quoted expressions as a syntax convention to get lists, the results will not be as expected.

Quoted expressions can be merged though.
This is useful for building code.

